fork系统调用

#include<sys/types.h>
#include<unistd.h>

pid_t fork(void);

写时复制：
  早期的unix系统中，创建进程调用fork()，内核会复制所有的内部数据结构，复制进程的页表项，然后把父进程的地址空间按页复制到子进程的地址空间中。
  现代unix系统采用了copy-on-write方式。是一种基于惰性算法的优化策略，为了避免复制时的系统开销，其前提假设是：如果有多个进程要读取它们自己的那部分资
  源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有一个进程修改自己的“副本”，每个进程就好像独占那个资源。
  从而避免了复制带来的开销。如果某个进程想要修改自己的那份资源“副本”，就会开始复制资源，并把副本提供给这个进程。复制过程对进程而言是“透明”的。
  这个进程后面就可以反复修改其持有的副本，而其他进程还是共享原来的那份没有修改过的资源。
  惰性算法的好处就是在于它们会尽量延迟代价高的操作，直到必要时才执行。
  写时复制在内核中实现：这些页被标记为只读，并对内核页相关的数据结构实现写时复制。如果有某个进程试图修改某个页，就会产生缺页中断。
  内核处理缺页中断的处理方式就是对该页执行一次透明复制。这时，清空该页的写时复制属性，表示这个页不再被共享。MMU上有硬件级别的写时复制支持。
