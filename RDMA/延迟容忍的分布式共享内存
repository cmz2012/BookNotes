
使用RDMA进行底层网络传输

摘要：Grappa，一种针对内存中数据密集型应用的现代式软件分布式共享内存。
      把集群看作是一个单个大型非均匀存储器存取机器。
      即便对于局部性差和依赖于输入的负载分布的应用来说，性能也提升很大
      Grappa通过挖掘应用并行性和用延迟换带宽的方式来解决先前分布式共享内存系统的缺点
      
介绍：数据密集型应用是大规模计算里很重要的一类，这些应用典型的硬件计算设备是通过高带宽的商用网络连接的多核结点的集合，也称为集群。
      软件分布式共享内存提供对集群的共享内存抽象。
      但是由于节点间的带宽限制，结点间的高延迟，使用虚拟内存系统做到全局内存无缝访问的设计，共同使得系统运行效率很差。
      之前的软件分布式共享内存是因为对称多处理器的出现而产生的，但是它只适用于那些表现出很强的局部性，有限制的共享和粗粒度同步的应用。
      对于现代数据密集型应用并不适用。
      Grappa不依赖于局部性来减少内存访问消耗，他依赖于并行化来保持处理器资源繁忙并且隐藏结点间通信的高耗费
      它包含一个将小型消息结合成大型物理网络包的覆盖网络，这最大化商用网络的可用对分带宽      
      通信层是建立在用户空间上，提供全局地址空间抽象。
      支持细粒度的共享而不是页级别的共享带来更好的效率，由于避免了页缺失的消耗，开启在全局内存访问的编译优化
      系统包含三个部分：全局地址空间，轻量级用户任务，聚集通信层
      
      在MAPREDUCE VERTEX-CENTRIC 和RELATIONAL QUERY EXECTION上实现分布式共享内存的难点在于：
      小型消息：共享内存模式下的程序经常访问小数据片导致结点间传输小型消息
               网络上涉及小型消息时，加载和存储操作就成了复杂的事务，相反，如果程序使用MPI，这个复杂性就交给了程序猿，鼓励他们优化它。
      局部性差：数据密集型应用经常表现出很差的局部性，针对图计算时，时间局部性和空间局部性都很差。
      需要细粒度的同步：图并行应用
      
      但是，数据密集型应用大量的数据并行化具有高度的并发性，性能取决于所有任务的总执行时间
      
Grappa设计：
      分布式共享内存：提供系统中任意位置细粒度的数据访问
                    全局内存的每一片由一个特定的core持有，访问远端结点上的数据是通过运行在持有该数据的核上的代理操作完成，读写操作
      任务系统：支持轻量级多线程和全局分布式任务窃取，并发通过用户级线程的合作调度来完成，执行长延迟的线程会自动挂起并自动唤醒。
      通信层：主要目标就是将小消息汇聚成大消息，这个过程对应用编程不可见。接口是基于active message的。
             【active message是一个消息对象，能够自己执行处理过程。是一个用来优化网络通信的轻量级消息协议，重在通过消除与缓存相关的软件代价并使
             应用程序直接从用户级别访问网卡来降低延迟。】
             因为消息汇总与消息拆分必须很高效，所以我们将这个过程并行化而且谨慎的使用无锁同步操作，为了方便，我们使用MPI作为底层消息库和进程的启动
             与销毁。
             
分布式共享内存：
      寻址模式：
            本地内存寻址：局限于grappa系统里一个结点上的一个核所持有的内存区域，访问方式就是传统的指针访问。
            可以访问：与任务相关的栈，从内存的本地核访问全局内存，访问每个系统结点局部的调试基件，本地指针不能访问其他核的内存，只在本地核上有效。
            全局内存寻址：每个核的堆栈上的数据可以被导出到全局地址空间，可以被系统上的其他核访问，使用划分全局地址空间(PGAS)寻址模式，每个地址是job的等级
                        或者全局进程ID和这个进程的地址的元组。
      代理操作：
            代理操作时执行在内存位置本地核的短操作。
            当数据访问模式具有很低的局部性时，在数据所隶属于的本地核上进行修改此数据要比从远端取过来一个数据拷贝然后返回修改过的数据要有效率的多。
            （代理可以普通的实现对全局内存的读写操作，他们也可以实现更复杂的读-修改-写和同步操作）
            代理操作必须在Grappa runtime上被显示的表达.
            它可以执行任何提供的代码而不会引起上下文切换，这保证了所有代理操作的原子性。
            为了避免上下文切换，一次代理操作只能修改被单个核持有的内存区。它总是在它修改数据地址的本地核上执行。
            （不会跨核访问，不会在单核上进行上下文切换，那么...）
            可以确保来自多个请求者对相同地址的代理操作是在单个核上串行执行，带来强独立性和原子性。
            
            
