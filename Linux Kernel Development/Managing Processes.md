# 2. 进程管理
## 2.1 进程
一个进程就是处于执行期的程序，但不仅仅局限于一段可执行程序代码，还包括其他资源，像用来存放全局变量的数据段，打开的文件，挂起的信号等，还包括地址空间以及执行线程。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。Linux内核调度的对象是线程，并不特别区分进程和线程，因为线程仅仅是可以共享资源的进程。
## 2.2 进程管理
内核把进程存放在叫任务队列(task list)的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构，该结构定义在include/linux/sched.h文件中。进程描述符包含一个具体进程的所有信息，包含：打开的文件，地址空间，挂起的信号，进程状态等等
### 2.2.1 分配进程描述符
Linux通过slab分配器分配task_struct结构，达到对象复用和缓存着色。各个进程的task_struct存放在内核栈的尾端，这样做是为了让那些像x86这样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置(内核栈大小固定)，从而避免使用额外的寄存器专门记录。由于现在用slab分配器动态生成task_struct，所以只需在栈底(对于向下增长的栈来说)或栈顶(对于向上增长的栈来说)创建一个新的结构struct thread_info。 在x86上，struct thread_info在文件<asm/thread_info.h>中定义。
### 2.2.2 进程描述符的存放
内核通过一个唯一的进程标识值或PID来标识每个进程，实际上就是一个int类型，为了与老版本的unix和linux兼容，PID的最大值默认为32768，可以通过/proc/sys/kernel/pid_max来提高上限。PID存放在进程描述符内部。在x86系统上，访问进程描述符时，通过把当前进程内核栈指针的后13个有效位屏蔽掉(也就是8K)，用来计算出thread_info的偏移，然后可以从该地址开始解析thread_info中的task域，最后拿到task_struct结构体内容。
### 2.2.3 进程状态
- TASK_RUNNING(正在执行或者在运行队列中等待执行)
- TASK_INTERRUPTIBLE(正在阻塞，等待某些条件的达成或收到信号被唤醒)
- TASK_UNINTERRUPTIBLE(正在阻塞，不会因为收到信号而唤醒)
- TASK_ZOMBIE(进程结束了，但是父进程还没有调用wait4()系统调用回收子进程的进程描述符)
- TASK_STOPPED(停止执行或者没有投入运行也不能投入运行。收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU或在调试期间收到任何信号都会进入此状态)
### 2.2.4 进程上下文
一般程序在用户空间执行，当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中(但是在中断上下文中，系统不代表进程执行)。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间继续执行。

## 2.3 进程的创建
在Linux系统中，fork()系统调用通过复制一个现有进程来创建一个全新的进程。调用结束时，在返回点这个相同的位置上，父进程恢复执行，子进程开始执行。子进程和父进程的区别仅仅在于PID，PPID和某些资源和统计量。通常创建新的进程是为了执行新的、不同的程序，而接着调用exec()这族函数就可以创建新的地址空间，并把新的程序载入。
### 2.3.1 写时拷贝(copy-on-write)
传统的fork()系统调用直接把所有的资源复制给新创建的进程，这种实现过于简单并且效率底下。Linux的fork()使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝，只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。在页根本不会被写入的情况下，比如fork()之后立即调用exec()，数据就完全不需要复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行文件，因此，这种优化是必要的。
### 2.3.2 fork()
Linux通过clone系统调用实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。fork()，vfork()，__clone()库函数都根据需要的参数标志取调用clone()。然后clone()调用do_fork()完成创建中的大部分工作，它定义在kernel/fork.c文件中，该函数调用copy_process()函数，然后让进程开始运行。copy_process:
- 为进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程相同
- 检查新创建子进程后，当前用户拥有的进程数量是否超出限制
- 子进程描述符内的许多成员要被清零或设为初始值，此时子进程与父进程区分开来
- 子进程的状态被设为TASK_UNINTERRUPTIBLE以保证它不会投入运行
- 更新task_struct中的flags成员，表明进程是否拥有超级用户权限的标志被清零，表明进程还没有调用exec函数的标志被设置
- 为新进程获取一个有效的PID
- 根据传递给clone的参数标志，拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。
- 让父进程和子进程平分剩余的时间片
- 作扫尾工作并返回一个指向子进程的指针
copy_process函数返回后，新创建的子进程被唤醒并让其投入运行，内核有意选择子进程首先执行(并非总能如愿)，因为一般子进程都会马上调用exec函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始先地址空间写入。
### 2.3.3 线程在linux中的实现
该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。Linux把所有的线程都当做进程来实现，内核并没有准备特别的调度算法或是定义特逼得数据结构来表征线程，相反，线程仅仅被视为一个使用某些共享资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中，它看起来就是一个普通的进程。线程的创建和普通进程的创建类似，只不过在调用clone()函数时要传递一些参数标志来指明需要共享的资源。Microsoft和Sun Solaris在内核中提供了专门支持线程的机制，叫做轻量级进程。
### 2.3.4 内核线程
内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成，它是独立运行在内核空间的标准进程。内核线程和普通的进程间区别在于没有独立的地址空间(mm_struct为NULL)，它们只在内核空间运行，从来不切换到用户空间去，可以被调度，被抢占。例如：pdflush, ksofirqd。内核线程也只能由其他内核线程创建。一般情况下，内核线程会将它在创建时得到的函数永远执行下去，该函数通常由一个循环构成，在需要的时候，这个内核线程就会被唤醒和执行，完成了当前任务，它会自行休眠。

## 2.4 进程退出
程序通过exit()系统调用退出执行(编译器会在main()函数的返回点后面放置调用exit()的代码)，或者收到不能处理也不能忽略的信号或异常时被动的终结，不管怎么终结，该任务大部分都要靠do_exit()来完成。do_exit:
- 将task_struct的标志成员设置为PF_EXITING
- 如果程序记账功能开启，acct_process()输出记账信息
- __exit_mm()放弃进程占用的地址空间，如果没有其他进程使用它们，就彻底释放
- sem__exit()如果进程排队等候IPC信号，则离开队列
- __exit_files()、__exit_fs()、exit_namespace()和exit_sighand()分别递减文件描述符、文件系统数据，进程名字空间和信号处理函数的引用计数。如果其中某些引用计数降为0，那么就可以释放
- 把存放在task_struct的exit_code成员中的任务退出代码置为exit()提供的代码中，或者取完成任何其他由内核机制规定的退出动作
- exit_notify()向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或者init进程，并把进程状态设为TASK_ZOMBIE
- 最后调用schedule()切换到其他进程，因为处于ZOMBIE的进程不会再被调度，因此这是进程所执行的最后一段代码
此时，进程占用的所有资源就是保存thread_info的内核栈和保存task_struct的那一小片slab，此时进程存在的唯一目的就是向它的父进程提供信息。父进程可以通过wait4()系统调用查询子进程是否终结，这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行后被设置为ZOMBIE状态，直到它的父进程调用wait()或waitpid()为止。
wait()这一族函数都是通过唯一的一个系统调用wait4()实现，它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的PID。此外调用该函数时提供的指针会包含子进程退出时的退出代码。最终当需要释放进程描述符时，release_task()会被调用：
- 调用free_uid()来减少该进程拥有者的进程使用计数
- 调用unhash_process()从pidhash上删除该进程，同时也要从task_list中删除该进程
- 如果这个进程正在被ptrace跟踪，将跟踪进程的父进程重设为其最初的父进程并将它从ptrace_list上删除
- 最后调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存
## 2.5 处理孤儿进程
如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个父亲，否则这些进程将永远处于ZOMBIE状态，无法回收内存。对于这个问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init进程作为它们的父进程。init进程会例行调用wait()来等待其子进程，清除所有与其相关的ZOMBIE进程。
