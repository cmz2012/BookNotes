# 3. 进程调度
调度程序是内核的组成部分，它负责选择下一个要运行的程序。调度程序可看作在可运行态进程之间分配有限的处理器时间资源的代码。只有通过合理的调度，系统资源才能最大限度的发挥作用，多进程才会有并发执行的效果。

多任务系统可以划分为两类：非抢占式多任务和抢占式多任务。Linux提供了抢占式多任务模式，在此模式下，由调度程序来决定什么时候停止一个进程的运行以便其他进程能够运行的时间是预先设置好的，叫进程的时间片，是分给每个进程的处理器时间段。有效管理时间片能使调度程序从系统全局的角度做出调度决定，避免个别进程独占系统资源。

## 3.1 I/O消耗型和处理器消耗型的进程
I/O消耗型进程的大部分时间用来提交I/O请求或是等待I/O请求；处理器消耗型进程把时间大多用在执行代码上，除非被抢占，否则它们通常都一直不停的运行。调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速和进程吞吐量高。

## 3.2 进程优先级
linux内核提供了两组独立的优先级范围。第一种是nice值，范围从-20到19，默认值为0，nice的值越大，优先级越低。nice值也决定分配给进程的时间片的长短，nice值为-20的进程获得的时间片最长。第二种是实时优先级，默认变化范围是0到99。任何实时进程的优先级都高于普通的进程。

## 3.3 时间片
时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。时间片过长会导致系统对交互的相应表现欠佳，让人觉得系统无法并发执行应用程序；时间片太短会明显增大进程切换带来的处理器耗时。此外，I/O消耗型进程不需要长的时间片，而处理器消耗型的进程则希望越长越好。因此，任何长时间片都会导致系统交互表现欠佳，默认的时间片很短，如20毫秒。注意，进程并非一定要一次性用完它所有的时间片。当一个进程的时间片耗尽了，就认为进程到期了，没有时间片的进程不会再投入运行，直到被重新分配了新的时间片。

## 3.4 进程抢占
进程抢占发生在两种情况下：
- 当一个进程的时间片变为0时，它会被抢占，调度程序被唤醒以选择一个新的进程
- 当一个进程进入TASK_RUNNING状态，内核会检查它的优先级是否高于当前正在执行的进程，如果是这样，调度程序会被唤醒，重新选择新的进程执行

注意，这是进程抢占，不包含正常的进程切换(进程主动放弃CPU)

## 3.5 调度算法
Linux的调度程序定义与kernel/sched.c中。新的调度程序可以达成以下目标：
- 实现O(1)调度
- 实现SMP的可扩展性。每个处理器拥有自己的锁和自己的可执行队列
- 强化SMP亲和力。尽量将相关一组任务分配给一个CPU进行连续的执行，只有在需要平衡任务队列的大小时才在CPU之间移动进程
- 加强交互性能
- 保证公平

### 3.5.1 可执行队列
调度程序中最基本的数据结构是运行队列。可执行队列定义域kernel/schedc中，由结构runqueue表示。可执行队列是给定处理器上的可执行进程的链表，每个处理器一个。每个可投入运行的进程都唯一的归属于一个可执行队列。为什么选择在kernel/sched.c中而不是在include/linux/sched.h中定义运行队列呢？因为设计者希望只给内核其他部分提供一个抽象接口，而把调度程序的具体实现代码隐藏起来。

### 3.5.2 优先级数组
每个运行队列都有两个优先级数组，一个活跃的和一个过期的。优先级数组使可运行处理器的每一种优先级都包含一个相应的队列，而这些队列包含对应优先级上的可执行进程链表，优先级数组还拥有一个优先级位图，当需要查找当前系统内拥有最高优先级的可执行进程时，它可以帮助提高效率。

### 3.5.3 重新计算时间片
许多操作系统在所有进程的时间片都用完时，采用一种显式的方法来重新计算每个进程的时间片，典型的实现是循环访问每个进程，根据进程的优先级和其他属性来重新分配时间片，但是弊端是：
- 可能会耗费相当长时间
- 重算时必须靠锁的形式来保护任务队列和每个进程描述符，这样所会加剧对锁的争用
- 重新计算时间片的时机是不确定的，这会给时间确定性要求很高的实时程序带来麻烦
linux的活跃优先级数组内的可执行队列上的每个进程都还有时间片剩余，而过期数组内的可执行队列上的进程都耗尽了时间片。当一个进程的时间片耗尽时，他会被移到过期数组，但在此之前，时间片已经重新计算好了。因此，只要在活动和过期数组之间来回切换就能实现重新计算所有进程的时间片，而数组是通过指针访问的，因此切换数组就是切换指针的时间。这种交换是O(1)级调度的核心。

### 3.5.4 计算优先级和时间片
进程拥有一个初始的优先级，叫做nice值，存放在进程task_struct的static_prio域中。程序用到的动态优先级存放在prio域中。动态优先级通过一个关于静态优先级和进程交互性的函数关系计算而来。这个函数是以nice值为基数，再加上-5到+5之间的进程交互性的奖励或罚分。Linux通过一个记录了进程用于休眠和执行的时间的值来判断一个进程的交互性强不强。该值存放在task_struct的sleep_avg域中。它的范围从0到MAX_SLEEP_AVG。sleep_vag的默认值为10毫秒。当一个进程从休眠状态恢复到执行状态时，sleep_avg会根据它休眠时间的长短而增长，直到达到MAX_SLEEP_AVG为止。相反，进程每运行一个时钟节拍，sleep_avg就做相应的递减，到0为止。

由于动态优先级本身已经以nice值和交互性为基础来取值，因此重新计算时间片只要以动态优先级为基础就可以了。当一个任务的时间片用完之后，就立即根据任务的动态优先级重新计算时间片，时间片的计算只需要把优先级按比例缩放，使其符合时间片的数值范围即可。

如果一个进程的交互性非常强，那么当它时间片用完后，它会被再放置到活动数组而不是过期数组中。因为在发生数组交换之前，放在过期数组中交互性很强的一个进程无法被执行，造成较长交互响应问题。判断交互性强不强是根据nice值静态判定，但是在判断之后还要判断过期数组内的进程是否已经饥饿了，也就是较长时间没有发生调度了，如果饥饿，那么此时交互性强的进程会放入到过期数组中，等待发生交换来解决饥饿。

### 3.5.5 睡眠和唤醒
当进程需要失眠时，进程把自己标记成休眠状态，把自己从可执行队列移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程正好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行队列。等待队列是由等待某些事件发生的进程组成的简单链表，内核用wake_queue_head_t来代表等待队列。关于休眠有一点需要注意，存在虚假的唤醒，有时候进程被唤醒并不是因为他所等待的条件达成了，所以才需要用一个循环处理来保证它等待的条件真正达成。例如：accept惊群，epoll惊群，线程池惊群，send中断等等。

## 3.6 负载均衡程序
负载均衡程序由kernel/sched.c中的函数load_balance()来实现。它有两种调用方法：
- 在schedule()执行的时候，只要当前的可执行队列为空，它就会被调用，此时只需要找到一些就绪进程并迁移到该队列中即可。
- 被定时器调用，系统空闲时每隔1毫秒调用一次或者在其他情况下每隔200毫秒调用一次，此时需要解决运行队列间所有的失衡。

负载均衡程序调用时需要锁住当前处理器的可执行队列并且屏蔽中断，以避免可执行队列的并发访问。具体操作如下：
- 首先，load_balance()从所有CPU的可执行队列中找到最繁忙的可执行队列，也就是进程数目最多。如果没有哪个可执行队列中进程数目比当前队列中的数目多25%及以上，那么就返回为NULL，不需要调度，否则，返回这个繁忙队列。
- 其次，load_balance()从最繁忙的队列中抽取一个优先级数组，最好是过期数组，因为数据可能已经不再处理器高速缓存中了，如果过期数组为空，那么只能选择活动数组
- 接着，load_balance()找到含有进程且优先级最高的链表，因为把优先级高的进程平均分散开来才是最重要的
- 分析找到的所有这些优先级相同的进程，选择一个不是正在执行，也不会因为处理器相关性而不可移动，并且不在高速缓存中的进程，抽取到当前队列。
- 只要仍然不均衡，就继续重复上面的步骤。最后，解除对当前运行队列的锁定。

## 3.7 抢占和上下文切换
上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在kernel/sched.c中的context_switch()函数负责处理。它会调用include/asm/mmu_context.h中的switch_mm()把虚拟内存从上一个进程映射切换到新进程中，再调用include/asm/system.h中的switch_to()函数从上一个进程的处理器状态切换到新进程的处理器状态，包括保存、恢复栈信息和寄存器信息。

内核提供了一个need_resched标志来表明是否需要重新执行一次调度，当某个进程耗尽它的时间片时，或者当一个优先级高的进程进入可执行状态时，该标志会被设置，此时，内核知道应该调用schedule()函数了。
### 3.7.1 用户抢占
从内核返回用户空间以及从中断返回用户空间的时候，内核会检查该标志来确定是否需要重新调度进程(因为既然它可以继续取执行当前进程，那么它当然可以再去选择一个新的进程取执行)。每一个进程内部都包含该need_resched标志(因为访问进程描述符内的数值要比访问一个全局变量快，描述符通常都在高速缓存中)。
### 3.7.2 内核抢占
只要重新调度是安全的，那么内核就可以在任何时间抢占正在执行的内核任务。所谓安全，就是内核任务没有持有锁。由于内核是支持SMP的，所以，只要没有持有锁，那么正在执行的代码就是可重新导入的，也即可抢占。为了支持内核可抢占，每个进程对的thread_info中引入了preempt_count计数器，该计数器初始值为0，每当使用锁的时候数值加1，释放锁的时候数值减1。数值为0的时候，内核就可执行抢占。如果need_resched被设置，并且preempt_count为0的话，这说明有一个更为重要的任务需要执行并且可以安全地抢占。内核抢占发生在：
- 当从中断处理程序返回内核空间的时候
- 当内核代码再一次具有可抢占性的时候
- 如果内核中的任务显式的调用schedule()
- 如果内核中的任务阻塞

## 3.8 实时
linux提供了两种实时调度策略：
- SCHED_FIFO
    - 不使用时间片，只要可以执行，就一直执行，多个进程轮流执行，直到全部完毕或者主动释放CPU
- SCHED_RR
    - 带时间片的SCHED_FIFO
- SCHED_OTHER
    - 非实时任务
在实时任务调度上，内核只使用静态优先级，保证给定优先级级别的实时进程总能抢占优先级比它低的进程。实时优先级的范围从0到MAX_RT_PRIO减1。默认情况下，MAX_RT_PRIO为100，所以默认的实时优先级范围是0到99。SCHED_OTHER级进程的nice值共享了这个取值空间，范围是MAX_RT_PRIO到(MAX_RT_PRIO + 40)，也就是说默认情况下，nice值从-20到19对应的实时优先级范围是从100到140。
