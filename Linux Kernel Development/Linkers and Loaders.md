# 1.CPU体系结构、操作系统和可执行文件格式
## 1.1 CPU体系结构
现在大部分PC机或者服务器使用的CPU都是X86_64指令集体系结构，这是一种基于CISC（复杂指令集体系结构）。除了CISC，还有另外一种RISC类型的CPU体系结构，也就是简单指令集体系结构，比如SUN的SPARC指令集，IBM的PowerPC指令集都是基于RISC指令集的CPU体系结构。那么在其中一种 CPU 体系结构中编译的代码能够在另一种体系结构下面运行么？

答案是否定的，因为所谓的二进制程序，其实都是有一条一条的CPU指令组成，二进制程序执行的过程中，也是由CPU把这些指令load到指令流中一条一条执行。不同的CPU体系结构的指令集是不一样的，指令的长度和组成都有区别。所以让SPARC的CPU去执行一个编译成X86的CPU指令集的二进制程序是不可行的。

## 1.2 操作系统与可执行文件格式
当年java语言刚兴起的时候，一个很大的卖点就是跨平台执行。为什么能够跨平台执行呢，这是因为java程序经过javac编译之后得到了一种java虚拟机可以执行的字节码文件。只要在不同的操作系统上（Windows，Linux，MacOS）上装上自己所属版本的java虚拟机之后，就可以执行在另外一种操作系统下面编译的java字节码程序。那么，为什么经过 gcc/g++编译过的二进制程序不能跨平台执行呢？

java程序能够跨平台执行是因为不同系统平台上面安装的java虚拟机能够识别同一种java字节码。那么不同的操作系统二进制程序不能跨平台执行，是因为不同操作系统下面二进制文件的格式不同。

一个程序编译成二进制之后，运行的时候是从main函数开始执行的。但是这个程序是怎么样load到内存中的，执行流又是如何准确的定位到main函数的地址的。这些工作都是操作系统替我们做的。可以大胆想一下，main 函数之前操作系统都需要做哪些工作。首先，操作系统肯定要分配一块虚拟地址空间；然后系统需要把二进制程序中的代码和数据 load 到这个地址空间中，随后系统会根据某种特定的文件格式，找到其中某一个特定的位置（初始化段），做一些程序运行前的初始化工作，比如环境变量初始化和全局变量的处理，然后开始执行我们的main函数。这里的“某种特定的文件格式”就是为什么二进制程序不能跨平台运行的原因。

每一种操作系统有自己的二进制文件格式，操作系统把二进制可执行程序load到内存中之后，会根据默认的这种格式寻找各种数据，比如代码段，数据段和初始化段。所以说 Windows下面的exe可执行文件，lib静态库，dll动态库是不可以直接运行在Linux系统下面的；MacOS下面的Mach-O可执行文件，静态链接库（a库），动态链接库（so库）也是不能够直接放在Linux系统下面运行的。反之亦然，Linux下面的ELF可执行文件，静态链接库（a库），动态链接库（so库）同样不能够在Window系统下面运行。

# 2. 编译器
不同的系统下有不同的编译器，比如Windows下有vs自带的C++编译器，Linux和Unix下面有gcc/g++编译器。也有很多不同的编程语言，各自有自己的编译器把相应的源代码编译成二进制可执行程序。

## 2.1 C语言基本概念
变量和函数
- 声明一个全局变量或者函数是告诉编译器，在当前的源文件中可能会用到这个变量或者调用这个函数，但是这个变量或者函数不在当前文件中定义，而会在其他的某个文件中定义，请编译器编译本文件的时候不要报错。
- 定义一个变量是告诉编译器在生成的目标文件中预留一个空间，如果变量有初始值，请编译器在目标文件中保存这个初始值。
- 定义一个函数是请编译器在这个文件的目标文件中生成这个函数的二进制代码

## 2.2 目标文件
在看编译器做了哪些事情之前，简单梳理一下程序至少需要做哪些事情：
- 默认 CPU 会根据程序的代码一条一条执行
- 当遇到了条件判断或者函数调用，程序就会发生指令流的跳转
- 程序代码执行的过程中需要操作各种变量指向的数据

可以推断出编译器至少需要做哪些事情：
- 编译器需要把代码编译成二进制指令
- 指令流跳转的时候，编译器需要为每个定义的函数所在的位置定义一个标签，每个标签有一个地址，调用每个函数的时候就相当于跳转到那个标签指向的地址 
- 访问变量的时候，编译器需要为每一个变量定义一个标签，每个标签同样有一个地址，这个地址指向内存中的数据空间

例子：
源文件
```c
int g_a = 1;            //定义有初始值全局变量
int g_b;                 //定义无初始值全局变量
static int g_c;         //定义全局static变量
extern int g_x;         //声明全局变量
extern int sub();     //函数声明

int sum(int m, int n) {        //函数定义
    return m+n;
}
int main(int argc, char* argv[]) {
    static int s_a = 0;     //局部static变量
    int l_a = 0;                 //局部非static变量
    sum(g_a,g_b);
    return 0;
}
```
编译并查看符号表信息：
```bash
gcc -c test.c -o test.o && nm test.o

0000000000000000 D g_a
0000000000000004 C g_b
0000000000000000 b g_c
                 U g_x
0000000000000014 T main
0000000000000004 b s_a.1597
0000000000000000 T sum
```
符号表解释：
- 最左边这一列是变量在所在段的相对地址，g_a和g_c的相对地址是相同的，这并不冲突，因为他们处于不同的段中（D和b表示它们在目标文件中处于不同的段中)
- 第二列表示变量所处的段的类型，比如我们这里看到了有 D,C,b,T 这些类型的段，比如D段就是数据段，专门存放有初始值的全局变量，T段表示代码段，所有的代码编译后的指令都放到这个段中。可以注意到同一个段中的变量相对地址是不能重复的
- 第三列表示变量的名字，这里局部的静态变量名字被编译器修改为s_a.1597，这么做的原因：s_a 是一个局部静态变量，作用域限制在定义它的代码块中，所以可以在不同的作用域中声明相同名字的局部静态变量，比如可以在sum函数中声明另外一个s_a。但是局部静态变量属于全局变量的范畴，它是存在于程序运行的整个生命周期的，所以为了支持这个功能，编译器对这种局部的静态变量名字加了一个后缀以便标识不同的局部静态变量
- 为什么这里的变量声明 g_x 没有地址呢？变量和函数的声明本质上是给编译器一个承诺，告诉编译器虽然在本文件中没有这个变量或者函数定义，但是在其他文件中一定有，所以当编译器发现程序需要读取这个变量对应的数据，但是在源文件中找不到的时候，就会把这个变量放在一个特殊的段（段类型为U）里面，表示后续链接的时候需要在后面的目标文件或者链接库中找到这个变量，然后链接成为可执行二进制文件

# 3. 链接器
首先尝试一下对上一节得到的目标文件链接一下看看有什么结果：
```bash
gcc test.o -o test

test.o: In function `main':
test.c:(.text+0x2c): undefined reference to `g_x'
collect2: ld returned 1 exit status
```
当我们尝试把这个目标文件进行链接成为可执行文件时，链接器报错了。因为之前通过变量声明承诺过的变量并没有在其他的目标文件或者库文件中找到，所以链接器无法得到一个完整可执行程序。我们尝试用另外一个C程序修复这个问题：
```c
int g_x = 100;
int sub() {}
```
把这个文件编译成目标文件:
```c
gcc -c test2.c -o test2.o; nm test2.o

0000000000000000 D g_x
0000000000000000 T sub
```
现在我们尝试把这两个目标文件链接成为可执行文件：
```bash
gcc test.o test2.o -o test; nm test
```
这时我们发现输出了比目标文件多很多的信息，其中定义了很多为了实现不同语言级别的功能而需要的段，在这里只看源文件中定义的那些变量对应的symbol及其地址，如下图所示：
```bash
00000000004005e8 T _fini
0000000000400390 T _init
00000000004003d0 T _start
...
0000000000601018 D g_a
0000000000601038 B g_b
0000000000601030 b g_c
000000000060101c D g_x
00000000004004c8 T main
0000000000601034 b s_a.1597
0000000000400504 T sub
00000000004004b4 T sum
```
在最终的可以执行文件里面可以看到：
- 在第一个源文件中声明的变量g_x和声明的函数sub最终在第二个目标文件中找到了定义
- 在不同目标文件中定义的变量，比如g_a,g_x都会放在了数据段中(段类型为D)
- 在目标文件中变量的相对地址全部变成了绝对地址

因此，链接器需要做的工作就是：
- 对各个目标文件中没有定义的变量，在其他目标文件中寻找到相关的定义
- 把不同目标文件中生成的同类型的段进行合并
- 对不同目标文件中的变量进行地址重定位

# 4. 装载器
## 4.1 动态链接库
在写程序的过程中，一般情况下会调用所需要的系统库和第三方库来实现功能。现在假设我们需要调用一个库函数提供的功能，我们来分析这个时候的可执行文件：
```c
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
    char buf[32];
    strncpy(buf, "Hello, World\n", 32);
    printf("%s",buf);
}
```
把这个文件编译成可执行文件并且查看一下它的symbols
```bash
gcc test3.c -o test3; nm test3

00000000004005b4 T main
                 U printf@@GLIBC_2.2.5
                 U strncpy@@GLIBC_2.2.5
```
我们应该能看到类似上述的输出。当时是在目标文件中，同样也是没有地址，我们说这是编译器留给链接器到后面的目标文件中寻找变量定义的。但是现在检查的是可执行文件，为什么可执行文件里面仍然有这种没有地址的symbols呢？ 因为这里可执行文件中的“未定义”的 symbols其实是为了支持动态链接库的功能。

所谓动态链接库是指，程序在运行的时候才去定位这个库，并且把这个库链接到进程的虚拟地址空间。对于某一个动态链接库来说，所有使用这个库的可执行文件都共享同一块物理地址空间，这个物理地址空间在当前动态链接库第一次被链接时load到内存中。

现在看一下二进制文件中对动态链接库中的函数怎么处理的：
```bash
objdump -D test3 | less
```
搜索printf我们应该能看到以下内容：
```bash
0000000000400490 <strncpy@plt>:
  400490:       ff 25 6a 0b 20 00       jmpq   *0x200b6a(%rip)        # 601000 <_GLOBAL_OFFSET_TABLE_+0x18>
  400496:       68 00 00 00 00          pushq  $0x0
  40049b:       e9 e0 ff ff ff          jmpq   400480 <_init+0x20>
...
00000000004004b0 <printf@plt>:
  4004b0:       ff 25 5a 0b 20 00       jmpq   *0x200b5a(%rip)        # 601010 <_GLOBAL_OFFSET_TABLE_+0x28>
  4004b6:       68 02 00 00 00          pushq  $0x2
  4004bb:       e9 c0 ff ff ff          jmpq   400480 <_init+0x20>
```
可执行文件中为strncpy和printf分别生成了代理symbol，然后代理symbol指向的第一条指令就是跳转到_GLOBAL_OFFSET_TABLE_这个symbol对应的代码段中的一个偏移位置。在linux中，这个_GLOBAL_OFFSET_TABLE_对应的代码段是为了给“地址无关代码”做动态地址重定位用的。动态链接库可以映射到不同进程的不同的虚拟地址空间，所以属于“地址无关代码”，链接器把对这个函数的调用代码跳转到程序运行时动态装载地址。

Linux提供了ldd命令查看一个可执行文件依赖的动态链接库：
```bash
ldd test3
```
ldd命令模拟加载可执行程序需要的动态链接库，但并不执行程序，后面的地址部分表示模拟装载过程中动态链接库的地址。如果尝试多次运行ldd命令，会发现每次动态链接库的地址都是不一样的，因为这个地址是动态定位的。平常工作中，如果某一个二进制可执行文件报错找不到某个函数定义，可以用这个命令检查是否系统丢失或者没有安装某一个动态链接库。

在这里继续总结一下链接器需要对动态链接库需要做的最基本的事情：
- 链接库在将目标文件链接成可执行文件的时候如果发现某一个变量或者函数在目标文件中找不到，会按照gcc预定义的动态库寻找路径寻找动态库中定义的变量或者函数
- 如果链接库在某一个动态链接库中找到了该变量或者函数定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理 symbol
- 在_GLOBAL_OFFSET_TABLE_代码中生成真正的动态跳转指令，并且在库函数（比如strncpy,printf）代理symbol中跳转到_GLOBAL_OFFSET_TABLE_中相应的偏移位置

## 4.2 装载和进入main函数之前的工作
在链接一节中展示了部分nm test的结果，其中_start这个symbol是故意被留下来的，因为对于elf文件格式来说，linux系统在为进程分配完虚拟地址空间并且把代码load到内存之后，是从这_start对应的地址开始执行的。这个地址记录在 elf 文件的头中，系统读取elf文件时可以得到这个地址。
```bash
0000000000400510 <_start>:
  ...
  400526:       48 c7 c1 70 06 40 00    mov    $0x400670,%rcx
  40052d:       48 c7 c7 f4 05 40 00    mov    $0x4005f4,%rdi
  400534:       e8 b7 ff ff ff          callq  4004f0 <__libc_start_main@plt> 
  /*
  .start这个段会去执行libc库中的__libc_start_main的指令，
  这里需要注意一下传给这个函数的两个参数值“0x400670”和“0x4005f4”，
  其中一个是__libc_csu_init的地址，一个是main函数的地址
  */
  ...

00000000004004f0 <__libc_start_main@plt>:
  4004f0:       ff 25 22 0b 20 00       jmpq   *0x200b22(%rip)        # 601018 <_GLOBAL_OFFSET_TABLE_+0x30>

0000000000400670 <__libc_csu_init>:
  ...
  4006b0:       e8 e3 fd ff ff          callq  400498 <_init>
  ...

0000000000400498 <_init>:
  ...
  4004a6:       e8 65 02 00 00          callq  400710 <__do_global_ctors_aux>
  ...

00000000004005f4 <main>:
  ...
  400626:       e8 95 fe ff ff          callq  4004c0 <strncpy@plt>
  ...
  40063f:       e8 9c fe ff ff          callq  4004e0 <printf@plt>
  ...
  400649:       e8 b2 fe ff ff          callq  400500 <sleep@plt>
  ...
```
首先在, \_start对应的指令中，经过一些处理之后，会用 __libc_csu_init的地址和main的地址作为参数调用 __libc_start_main，这个函数是在libc库中实现的，也就是linux中所有的可执行程序都共享同一段初始化代码，在 __libc_start_main作为一些处理之后，会先调用 __libc_csu_init对应的指令，然后调用main对应的指令, main对应的指令就是main函数了， __libc_csu_init接着会调用_init的指令，然后调用 __do_global_ctors_aux指令进行所有的全局变量初始化，或者C++中的全局对象构造等操作

总结一下当我们通过bash运行一个程序的时候，Linux 做了哪些事情：
- 首先bash进行fork系统调用，生成一个子进程，接着在子进程中运行 execve 函数指定的elf二进制程序（Linux中执行二进制程序最终都是通过 execve 这个库函数进行的），execve会调用系统调用把elf文件load到内存中的代码段(_text)中
- 如果有依赖的动态链接库，会调用动态链接器进行库文件的地址映射，动态链接库的内存空间是被多个进程共享的
- 内核从elf文件头得到\_start的地址，调度执行流从\_start指向的地址开始执行，执行流在\_start执行的代码段中跳转到libc中的公共初始化代码段__libc_start_main，进行程序运行前的初始化工作。
__libc_start_main的执行过程中，会跳转到_init中全局变量的初始化工作，随后调用main函数，进入到主函数的指令流程
