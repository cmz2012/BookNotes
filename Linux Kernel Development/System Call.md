# 4.系统调用
为了和用户空间上运行的进程进行交互，内核提供了一组界面。透过该界面，应用程序可以访问硬件设备和其他操作系统资源。这组界面在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些需求(或让应用程序暂时搁置)。

系统调用在用户空间进程和硬件设备之间添加了一个中间层，作用是：
- 它为用户空间提供了一种硬件的抽象界面
- 系统调用保证了系统的稳定和安全
- 维持进程运行在虚拟系统中的抽象

## 4.1 API、POSIX和C库
一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。因为API可以在不同的操作系统上实现，给应用提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。

在unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于unix的可移植操作系统标准。

C库实现了unix系统的主要API，包括标准C库函数和系统调用。

关于unix的界面(指函数界面)设计有一句通用的格言“提供机制而不是策略”

## 4.2 系统调用
系统调用通常通过函数进行调用。通常，用一个负的返回值来表明错误，用0来表明成功。出错时，会把错误码写入到errno全局变量，通过perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。

### 4.2.1 系统调用号
在linux中，每个系统调用被赋予一个系统调用号。当用户空间进程执行一个系统调用的时候，这个系统调用号就被用来指明到底要执行哪个系统调用，进程不会提及系统调用的名称。

针对被删除的系统调用，其系统调用号不会被回收，针对无效的系统调用，linux中有一个sys_ni_syscall()，它除了返回-ENOSYS外不做任何其他工作。

## 4.3 系统调用处理程序
用户空间的程序无法直接执行内核代码，因此不能直接调用内核空间的函数，那么当用户空间程序希望调用系统调用的时候，就需要通知系统切换到内核态，由内核来代表应用程序执行系统调用。

通知的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态取执行异常处理程序。此时的异常处理程序就是系统调用处理程序。x86系统上的软中断由int $0x80指令产生。这条指令会触发一个异常，导致系统切换到内核态并执行第128号(8*16)异常处理程序，名字叫system_call()，与硬件体系结构紧密相关，通常在entry.S文件中用汇编语言编写。

### 4.3.1 指定恰当的系统调用
因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间还不够。必须把系统调用号一并传给内核。在x86系统上，这个传递动作是通过在触发软中断前把系统调用号装入eax寄存器实现的，这样系统调用处理程序一运行就可以从eax中得到系统调用号。

### 4.3.2 参数传递
除了系统调用号以外，大部分系统调用都还需要一些用户空间的参数输入，因此也需要拷贝到内核空间中。在x86系统上，ebx,ecx,edx,esi和edi按照顺序存放前五个参数。其他参数用一个单独的寄存器存放指向所有这些参数在用户空间的地址。给用户空间的返回值也是通过寄存器传递。在x86系统上，它存放在eax寄存器中。

### 4.3.3 参数验证
系统调用必须仔细检查它们所有的参数是否合法有效。

最重要的一种检查就是检查用户提供的指针是否有效，比如：
- 指针指向的内存区域属于用户空间
- 指针指向的内存区域在进程的地址空间里
- 如果是读，该内存应该被标记为可读；否则，应该别标记为可写

内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝：
- copy_to_user(dst, src, len)
- copy_from_user(dst, src, len)

## 4.4 系统调用上下文
内核在执行系统调用的时候处于进程上下文。current指针指向触发系统调用的那个进程。

在进程上下文中，内核可以休眠(阻塞)并且可以被抢占。
- 能够休眠说明系统调用可以使用内核系统的绝大部分功能
- 能够被抢占表明像用户空间内的进程一样可以被其他进程抢占，该系统调用是可重入的

当系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到用户空间并让用户空间进程继续执行下去

## 4.5 从用户空间访问系统调用
通常，系统调用靠C库支持。用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。此外，linux本身提供了一组宏，用于直接对系统调用进行访问，它会设置好寄存器并调用int $0x80指令。这些宏是_syscalln()，n从0到6，代表需要传递给系统调用的参数个数，这是由于宏必须了解到底有多少参数按照什么次序压入寄存器。例如：
```c
long open(const char* filename, int flags, int mode);
#define NR_open 5 //此处是系统调用号
_syscall(long, open, const char*, filename, int, flags, int, mode);
```
对于每个宏来说，都有2+2×n个参数。第一个参数是返回值类型，第二个参数是系统调用名称，再往后就是系统调用参数类型和名称。
