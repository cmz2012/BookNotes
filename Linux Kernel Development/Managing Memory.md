# 10. 内存管理
## 10.1 页
内核把物理页作为内存管理的基本单位。从虚拟内存的角度来看，页就是最小单位。
内核用struct page结构表示系统中的每个物理页，该结构位于linux/mm.h中：
```cpp
struct page {
    unsigned long           flags; //页的状态，包括脏页、锁定等等
    atomic_t                count; //页的引用计数
    struct list_head        list;
    struct address_space    *mapping; //指向与该页相关的地址空间对象
    unsigned long           index;
    struct list_head        lru;
    union {
        struct pte_chain    *chain;
        pte_addr_t          direct;
    } pte;
    unsigned long           private;
    void                    *virtual; //页的虚拟地址
};
```
该结构对页的描述只是短暂的，即使页中所包含的数据继续存在，但由于交换等原因，它们可能并不再和同一个page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。
内核使用这一结构来管理系统中所有的页，因为内核需要直到一个页是否空闲，如果已经被分配，谁拥有这个页，拥有者可能是用户空间的进程、动态分配的内核数据结构、静态内核代码、或页高速缓存等等。

## 10.2 区
由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这个限制，所以内核把页划分为不同的区。内核使用区对具有相似特性的页进行分组。Linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题：
- 一些硬件只能用某些特定的内存地址来执行DMA
- 一些体系结构其内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能永久的映射到内核空间上
Linux使用了三种区：
- ZONE_DMA
    - 这个区包含的页能用来执行DMA操作
- ZONE_NORMAL
    - 这个区包含的都是能正常映射的页
- ZONE_HIGHMEM
    - 这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间

区的实际使用和分布是与体系结构相关的。例如在x86体系结构上，ISA设备就不能在整个32位的地址空间中执行DMA，因为ISA设备只能访问物理内存的前16MB，因此，ZONE_DMA在x86上包含的页都在0~16MB的内存范围里。ZONE_HIGHMEM的工作方式也取决于体系结构。在x86上，ZONE_HIGHMEM为高于896MB的所有物理内存。在x86上，ZONE_NORMAL是从16MB到896MB的所有物理内存。

区的划分没有任何物理意义，这是不过是内核为了管理页而采取的一种逻辑上的分组。尽管某些分配可能需要从特定的区中获取页，但这并不是说，某种用途的内存一定要从对应的区获取。

## 10.3 获取页
几个低级页函数
- struct page* alloc_pages(unsigned int gfp_mask, unsigned int order);
- void* page_address(struct page* page);
- unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order);
- unsigned long get_zeroed_page(unsigned int gfp_mask);
- void __free_pages(struct page* page, unsigned int order);
- void free_pages(unsigned long addr, unsigned int order);
- void free_page(unsigned long addr);

高级内存分配函数，以字节为单位的分配
- void* kmalloc(size_t size, int flags);
    - 分配物理地址连续的内存
- void kfree(const void* ptr);
- void* vmalloc(unsigned long size);
    - 分配虚拟地址连续的内存
    - 该函数可能会睡眠，因此，不能从中断上下文进行调用，也不能从其他不允许阻塞的情况下进行调用

## 10.4 slab层
分配和释放数据结构是所有内核宏最普遍的操作之一。为了便于数据的频繁分配和回收，编程者常常会用到一个空闲链表。该空闲链表包含有可用使用的、已经分配好的数据结构块。当代码需要一个新的数据结构实例时，就可以从空闲链表中抓取一个，而不需要分配内存，再把数据放进去。然而，在内核中，空闲链表面临的主要问题是不能全局控制，也即收缩内存非常棘手，因为内核根本不知道空闲链表的存在。

slab分配器的概念首先在Sun Microsystem的SunOS 5.4操作系统中得以实现。它的设计思想是：
- 频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们
- 频繁分配和回收必然会导致内存碎片(难以找到大块连续的可用内存)。为了避免这种现象，空闲链表的缓存应当连续的存放。
- 回收的对象可以立即投入下一次分配。因此，对于频繁的分配和释放，空闲链表能够提高其性能。
- 如果让部分缓存专属于单个处理器，那么分配和释放就可以在不加SMP锁的情况下进行。
- 对存放的对象进行着色，以防止多个对象映射到相同的高速缓存行。

slab设计
- slab层把不同的对象划分为所谓高速缓存组(caches)
    - 其中每个高速缓存都存放不同类型的对象。每种对象类型对应一个高速缓存，例如，一个高速缓存用于存放进程描述符，另一个用于存放索引节点对象。kmalloc()接口建立在slab层之上，使用了一组通用高速缓存。
- 这些高速缓存又被划分成slabs，每个高速缓存可以由多个slab组成，一个slab由一个或多个物理上连续的页组成。
- 每个slab包含一些对象成员(被缓存的数据结构)。
- 当内核的某一部分需要一个新的对象时，先从对应的高速缓存中部分满的slab中进行分配，如果没有部分满的slab，就从空的slab中进行分配。如果没有空的slab，就新创建一个slab。

## 10.5 在栈上的静态分配
内核栈大小固定，在大多数32位体系结构上，栈为8KB。在64位的体系结构上，栈为16KB。通过给每个进程分配一个固定大小的栈，不但可以减少内存的消耗，而且内核也无需负担太重的管理任务。

每个进程都有自己的内核栈，进程在内核执行期间的整个系统调用链必须放在自己的内核栈上。中断处理程序也使用被它们打断的进程的堆栈。这就意味着，在最恶劣的情况下，8KB的内核栈可能会由多个函数的嵌套调用链和几个中断处理程序来共享。深度的嵌套会导致溢出。

由于内核没有在管理内核栈上做足工作，因此在内核栈溢出时，悄无声息但一定会引起严重的问题。当栈溢出时，多出来的数据就会直接溢出来，覆盖掉紧邻堆栈末端的东西，首先遭殃的是thread_info，因为这个结构就在进程内核堆栈的末端。

## 10.6 高端内存的映射

