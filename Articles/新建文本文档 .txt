什么是缓存一致性？DMA缓存一致性有什么用
nic存储页表的容量有限，因此大多将页表存在系统内存中，而把NIC的内存当作一种cache，性能是问题
回调函数有什么鸟用
因为机器映射到K个环上，那么机器就能存储不同的数据，可以并行恢复数据，但是问题是你这不是破坏了数据一致性吗？单个环上的数据存储位置是确定的，但是环与环之间上数据的存储位置就是有差别的？
每个对象在共享地址空间上的地址是：32位region 标识符 和 32位偏移地址，
每个region是2GB，32位region标识符是由  环上的位置和环编号组成，问题是我可以找到数据存储的机器，但是我怎么找到机器上哪个region啊

申请region时，region allocator 会随机选一个环，然后在环上找到离本地结点附近的一个位置作为region identifier，目的是确保主备份在本地结点上。注意，是随机选择一个环，也就是说每个环上包含的内存区域绝对不相交，但是机器上存储的region是可以相交的

复制备份带来的问题，累加消耗内存太大

区域标识符通过一致性哈希映射到环上的机器上
区域标识符由环上的位置和环编号组成。
机器通过一致性哈希映射到环上


事务就是写  读不用事务
会不会有一台机器既是主备份  又是副本备份  ？不可能  因为每块内存区域只会出现在一个环上
给读集合的对象的主备份发送消息是为了检查自己读的对象的版本是最新的
事务机制解决的是在乐观并发控制之后怎么维持内存一致性的问题。
为什么被修改的对象被锁住，事务就会失败	
无锁读就是说读不需要加锁？傻逼吗？结果你还不是需要看别人写操作的脸色，其实就是一看到别人加锁了，你就滚回去呆一会再过来看看能不能读
读写顺序性是通过匹配头部ersion时的memory barrier实现的。


哈希表的实现：
	存储 键和共享对象的胖指针(key,fat pointers)
	使用胖指针是为了应对值的size是可变的
	
	目标是设计一个好的哈希表，每次查询时使用尽可能少的RDMA操作
	就是说查询的条目内容尽可能少，那么一次能查询的条目就尽可能的多，
	进而就能在少数RDMA查询操作中找到目标键对应的值存储在哪(类似于文件系统
	里的inode结点)
	另外还要注意空间效率，就是说利用率要高。
	hopscotch式哈希是指，映射到某个键Key的值应该存储在这个key附近后续H个
	位置范围内，限定范围就能准确估量算法复杂性的上界
	
这个算法得保证键值对存储在一小块连续的内存区域，而且只要一次RDMA读就能找到。
问题是H设大了会导致RDMA读的内容也多，平均下来需要的RDMA操作也多了，
H设小了就可能频繁的重新调整哈希表，导致空间利用率很低。
但是RDMA一次读的内容越多，平均每秒的请求率也就急剧下降，如果能在次数少的
小型RDMA读操作里完成，性能就能大大提高。

仅仅是hopscotch还不够，新算法使用链式结合的hopscotch
改进在于：对于插入操作如果不能在H个邻近的bucket找到空位置，那就把它插入到
这个键的bucket的溢出块链里。好处是限制了线性探测的长度。
每个bucket是一个FaRM对象，带有H/2个插槽来存储键值对。那么这样以来，任意的键必然存储
在当前bucket或者下一个bucket里面。
溢出块链表并不能完全解决resize的问题，只能改善性能和空间效率
使用一致性哈希来把哈希值分布在所有的哈希碎片里确保弹性。
查询搜索是在键Key对应的bucket B和B+1里面找，找不到就去B的溢出块链表里找。
链表使用胖指针来把块链接起来。会把胖指针里的incarnation数和块里面的incarnation数
进行比较，相同就查询完成。
对于哈希表查询，我们必须保证相邻的两个buckets是彼此一致的。加入joint versions
每个bucket存储一个前向joint versions和一个后向versions。
更新邻近的buckets会增加对应的joint versions
