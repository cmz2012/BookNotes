特定实现的详细细节也许允许客户端(使用接口的人)编程人员安排对不同内存单元中的内存地址并发内存访问来最小化竞争。
要么是客户端要么是共享虚拟内存存储分配器会使用这种访问策略，但是这也许会导致不能高效使用内存。因此，竞争的可能性暗示需要相对小的内存单元。
页大小的尺寸选择和传统虚拟内存页大小一致可以利用现有的页错误机制。
尤其是可以利用MMU中的保护机制，它允许单指令触发页错误并且陷入合适的错误处理中。(???)
程序可以以这样一种方式来设置对页的访问权限：会破坏内存一致性的内存访问将引起一个页错误；内存一致性问题就可以在页错误处理者和错误服务者中以组合的方式
来就解决。

内存一致性策略：
    解决方法可以分为：页同步和页持有权两类
        页同步：
              两个基本解法解决页同步问题：页失效和写广播
                    在页失效策略中：每一个页只有一个主处理器(享有持有权).它可以读也可以写。
                                   如果处理器Q对页P有写错误，那么错误处理就
                                          ---把所有P的副本都失效
                                          ---把对P的权限改为写
                                          ---如果Q没有P的副本就取一个副本
                                          ---返回到引起错误的指令中
                                   返回后，处理器Q就成为了P的主处理器，它可以继续写操作和其他的读写操作，直到页的持有权限被让给其他处理器。
                                   如果处理器Q对页P有一个读错误，那么错误处理就
                                          ---把对P有写权限的处理器改成读
                                          ---取一个P的副本到Q上并且把P的权限设为读
                                          ---返回到引起错误的指令上
                     在写广播策略中：处理器处理读错误的方式和页失效中一样，
                                    如果处理器有写错误，那么错误处理就
                                          ---对所有该页的副本执行写操作
                                          ---返回到引起错误的指令上
                                    这种方式的主要问题是他需要特殊的硬件支持：每次对共享页的写操作都需要在写处理器上产生一个错误，并且更新所有的副本
                                    因为共享虚拟内存的哲学就是要求所有的页是自由的共享。为了防止处理器在返回到引发错误指令上时在此有同样的页错误，
                                    硬件必须能够跳过这个故障写周期。
         页持有权：
                 页的持有权可以是固定的也可以是动态的。
                    固定式是不可能的，不予考虑。
                    维持动态页持有权的策略可以分为两类：集中式和分布式，分布式管理也可以根据持有数据的分布进一步分为固定的和动态的。
         最好的是两种策略组合使用，可以考虑的组合是集中式管理配上页失效，固定分布式管理配上页失效，动态分布式管理配上页失效。
                    
         页表，锁和失效：
            解决内存一致性的算法是通过用页错误处理，错误服务和使用的数据结构。数据结构至少有以下关于每个页的信息：访问权限，副本集，锁。也就是页表。
            页表的锁域上有两种原语操作，lock，unlock。同步多个页错误请求。
            在内存一致性算法中使用的另一个原语是 invalidate
            至少有三种使页副本失效的方式：独立式，广播式，多播式。
            合理假设远程操作都需要两个消息：一个请求和一个回复。
            在这种假设下，对于N个处理器系统上m个副本：
                            独立失效请求：需要2m个消息{m个请求，m个回复}
                            广播失效请求：{发送m+1个消息，收到N+m-1个消息(N-1个消息是并行接受的)}
                            多播失效请求：{发送m+1个消息，收到2m个消息(m个消息是并行接受的)}
                            
                            当N较小时可以使用bit vector来表示副本集
                            当N较大时，可以使用：linked bit vector,neighbor bit vector,vaguely defined set.
