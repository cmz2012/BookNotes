摘要：
    FaSST是一个基于RDMA支持有序性和持久性的分布式内存事务系统。
    现存的基于RDMA事务处理系统使用one-sided RDMA通信原语，因为它们能绕过远端CPU。
    这种设计选择带来一些缺点：1.设计分布式数据存储时，one-sided RDMA缺乏灵活性会降低性能和增加软件复杂度。
                            2.RDMA硬件的深层技术短板限制了在大规模集群的可扩展性。
简介：
    可序列化的分布式事务为像对象存储和在线事务处理系统的分布式系统设计提供强有力的编程抽象。
    虽然以前在这方面的工作为性能奉献了健壮的事务语义，最近的一些系统已经展现了数据中心的事务可以很快。
    关键因素就是高速网络和轻量级网络栈。这些系统的公共特征就是他们广泛使用one-sided RDMA操作，可以绕过远端cpu。
    在这片文章里，我们探求是否one-sided RDMA是不是设计事务处理系统的最佳选择。
    
    首先，在one-sided RDMA范式和访问远程数据存储的高效事务所需的能力之间存在分歧。
    one-sided RDMA只提供读，写和原子操作，而访问远程数据存储通常都涉及遍历数据结构如哈希表和B树。
    通常这些结构都包含一个用于快速查询的索引和实际的数据，需要两个或两个以上的RDMA读来访问数据。
    这会导致低带宽和高延迟，从远端cpu旁通而减少了网络处理器的节省（也就是说远端cpu负载减少了，但是网络处理器的负载增加了）
    克服这个分歧的关键方法就是展平数据结构(flatten)，要么去掉索引，要么把数据和索引合并在一起，或者在所有的服务器上缓存索引。
    
    其次，当前one-sided RDMA实现的以连接为导向的本性通常需要cpu核之间共享本地NIC queue pairs 获得扩展性，而本地每个核的RDMA吞吐量
    和绕过远端cpu获得的网络收益都减少了几分之一。
    通过two-sided 不可靠数据报消息的rpc，在消息处理上牵涉到远端cpu，比one-sided RDMA更加灵活，允许数据访问在单个往返内完成。
    FaSST：一个多对多的RPC系统  允许Doorbell batching（通过减少CPU初始化的 pcie总线事务数量来节省CPU周期）
 
背景：
    快速分布式事务：
        FaSST目标是提供在单个数据中心内的分布式事务，这里系统个单个实例可以扩展到几百个结点。
        系统中的每个结点负责一块基于一个主键的数据，并且每个结点既是server又是client，对于数据局部性好的负载(只访问一块内数据的事务)，这种
        对称模型可以通过将它们访问的数据放在同一个事务里来获得更高的性能。
        使得数据在机器发生故障时持久化需要把事务记录到持久性存储里，快速恢复需要维持数据存储的多个备份。
        将持久存储（如磁盘或SSD）置于事务的关键路径上会限制性能。
        和最近的工作一样，FaSST假设事务处理结点配备有后备电池的DRAM。
     RDMA：
        有连接的传输提供one-sided的RDMA和端到端的可靠性，但是不能很好的扩展到大型集群上。
        这是因为NIC用来缓存QP状态的内存有限，使用太多QP而超过这个状态的大小会导致缓存抖动。
        无连接的传输不提供one-sided RDMA或者端到端可靠性。然而，他们允许一个QP可以和多个其他QP通信，并且比有连接的传输具备更好的可靠性，
        因为每个线程只需要一个QP。(一个线程可能给多个远端线程通信，但是只需要一个QP)
        现代高速网络包括mellanox的infiniband和intel的omniPath，在传输层以下提供可靠性。他们的链路层使用流控制来防止
        基于拥塞的丢包和重传来防止bit基于错误的丢包。Infiniband的物理层使用前向错误纠正(FEC)来修正大多数位错误，这个本身很少出现。
        例如：我们集群中使用的infiniband 线路的位错误率低于10^-15。也就是说有了这些基础，这些网络的链路层流控制在极少情况下会出现拥塞崩溃，
        带来低吞吐量，但是不会丢包。
        
选择网络原语：
    RPCs的优势：
        讨论两种降低READ数量的优化措施和他们的限制。
        索引和值在一起：
            FaRM使用一个专用索引把值存储在索引临近的位置上来提供哈希表访问在大约1次READ，允许数据和索引一起读。
            然而这样做会把READ的size放大6～8倍，减小了吞吐量。这个结果强调比较网络原语的应用级性能的重要性：虽然微测试表明READs比
            大小类似的RPCs表现要好，但是由于one-sided本性，READs需要额外的网络流量和往返次数，在另一方面限制了规模。
         缓存索引：
            在单结点事务处理系统里，流行的在线事务处理测试上索引占用超过35%的内存，和我们的分布式事务处理实现测试的比率相近。
            在我们这个情况下，缓存10%的索引需要每台机器奉献整个集群内存容量的3.5%来存储索引，但集群包含超过100/3.5=29个结点时就几乎不可能了。
            The cell B Tree 缓存B树在叶子节点之上的4层的结点来节省内存和减少抖动，但是当client使用READs来访问B树的时候就要多次往返(大概4次)。
         RPCs允许通过两个消息就能访问分块数据，请求和回复。它们不会增加消息大小，也不需要多次往返，也不用缓存。
         基于RPC编程的简单性减少了软件复杂性(在事务处理中需要利用现代快速网络：来实现一个分块的，分布式数据存储)，用户仅仅为一个单结点数据存储
         写很短的RPC处理程序。
